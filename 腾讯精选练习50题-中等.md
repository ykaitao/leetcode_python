# [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

示例 1：

<img src=https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg width="700"/>

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```
示例 2：
```
输入：l1 = [0], l2 = [0]
输出：[0]
```
示例 3：
```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

提示：
```
每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零
```

代码：
```python3
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        head_copy = head = ListNode()
        carry = 0
        while l1 or l2:
            l1_val = l1.val if l1 else 0
            l2_val = l2.val if l2 else 0
            s = carry + l1_val + l2_val
            if s < 10:
                node = ListNode(s)
                carry = 0
            elif s >= 10:
                node = ListNode(s - 10)
                carry = 1
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
            head.next = node
            head = node
        
        if carry == 1:
            head.next = ListNode(1)
        return head_copy.next
```

# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。


示例 1：
```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```
示例 2：
```
输入：s = "cbbd"
输出："bb"
```
示例 3：
```
输入：s = "a"
输出："a"
```
示例 4：
```
输入：s = "ac"
输出："a"
```

提示：
```
1 <= s.length <= 1000
s 仅由数字和英文字母（大写和/或小写）组成
```

代码：
```python3
class Solution:
    def longestPalindrome(self, s: str) -> str:
        # 方法一，中心扩散：
        n = len(s)
        def center_expend(c1: int, c2: int) -> Tuple[int, int]:
            while c1 >= 0 and c2 < n and s[c1] == s[c2]:
                c1 -= 1
                c2 += 1
            return c1 + 1, c2 - 1

        max_len = -inf
        i_max, j_max = 0, 0
        for k in range(n):
            for m in [0, 1]:
                i, j = center_expend(k, k + m)
                curr_len = j - i + 1
                if max_len < curr_len:
                    max_len = curr_len
                    i_max, j_max = i, j
        return s[i_max: j_max + 1]


        # 方法二，动态规划：
        n = len(s)
        dp = [[False] * n for _ in range(n)]  # 不能写成 dp = [[False] * n] * n
        for i in range(n):
            dp[i][i] = True

        length_max = -inf
        i_max, j_max = 0, 0
        for length in range(2, n + 1):
            for i in range(n):
                j = i + length - 1
                if j >= n:
                    break
                if s[i] != s[j]:
                    dp[i][j] = False
                else:
                    if length == 2:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                if dp[i][j] and length_max < length:
                    length_max = length
                    i_max, j_max = i, j 

        return s[i_max: j_max + 1]
```

# [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：
```
读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
```
注意：
```
本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
```

示例 1：
```
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
```
示例 2：
```
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
```
示例 3：
```
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。
```
示例 4：
```
输入：s = "words and 987"
输出：0
解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。
```
示例 5：
```
输入：s = "-91283472332"
输出：-2147483648
解释：
第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
          ^
第 3 步："-91283472332"（读入 "91283472332"）
                     ^
解析得到整数 -91283472332 。
由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。
```

提示：
```
0 <= s.length <= 200
s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成
```

代码：
```python3

```

# [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
```
说明：你不能倾斜容器。
```
 

示例 1：

<img src=https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg width="700"/>

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
示例 2：
```
输入：height = [1,1]
输出：1
```
示例 3：
```
输入：height = [4,3,2,1,4]
输出：16
```
示例 4：
```
输入：height = [1,2,1]
输出：2
```

提示：
```
n = height.length
2 <= n <= 3 * 104
0 <= height[i] <= 3 * 104
```
代码：
```python3
class Solution:
    def maxArea(self, height: List[int]) -> int:
        i, j = 0, len(height) - 1
        max_area = 0
        while i < j:
            curr_area = (j - i) * min(height[i], height[j])
            if max_area < curr_area:
                max_area = curr_area
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
        return max_area
```

# [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
```
注意：答案中不可以包含重复的三元组。
```
 

示例 1：
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```
示例 2：
```
输入：nums = []
输出：[]
```
示例 3：
```
输入：nums = [0]
输出：[]
```

提示：
```
0 <= nums.length <= 3000
-105 <= nums[i] <= 105
```

代码：
```python3
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        if n < 3:
            return []

        res = []
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]: continue
            if nums[i] > 0:
                return res
            j = i + 1
            k = n - 1
            target = -nums[i]
            while j < k:
                sumjk = nums[j] + nums[k]
                if sumjk == target:
                    res.append([nums[i], nums[j], nums[k]])
                    # 站在当前消未来重复的，j的未来是 j+1，k的未来是 k-1
                    while j < k and nums[j + 1] == nums[j]: j += 1
                    while j < k and nums[k - 1] == nums[k]: k -= 1
                    j += 1
                    k -= 1
                elif sumjk < target:
                    while j < k and nums[j + 1] == nums[j]: j += 1
                    j += 1
                elif sumjk > target:
                    while j < k and nums[k - 1] == nums[k]: k -= 1
                    k -= 1
        return res

```

# [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。


示例：
```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

提示：
```
3 <= nums.length <= 10^3
-10^3 <= nums[i] <= 10^3
-10^4 <= target <= 10^4
```

代码：
```python3
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        n = len(nums)

        sum_best = 0
        error_best = +inf
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            j = i + 1
            k = n - 1
            while j < k:
                sum_curr = nums[i] + nums[j] + nums[k]
                error_curr = abs(target - sum_curr)
                if error_best > error_curr:
                    error_best = error_curr
                    sum_best = sum_curr
                
                if sum_curr == target:
                    return sum_curr
                elif sum_curr > target:
                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1
                    k -= 1
                elif sum_curr < target:
                    while j < k and nums[j] == nums[j + 1]: 
                        j += 1
                    j += 1
        return sum_best


```

# [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

 

示例 1：
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```
示例 2：
```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```
示例 3：
```
输入：nums = [1], target = 0
输出：-1
```

提示：
```
1 <= nums.length <= 5000
-10^4 <= nums[i] <= 10^4
nums 中的每个值都 独一无二
题目数据保证 nums 在预先未知的某个下标上进行了旋转
-10^4 <= target <= 10^4
```

代码：
```python3
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        n = len(nums)

        i, j = 0, n - 1
        while i <= j:
            m = i + (j - i) // 2

            # target on left, num[m] on right
            if nums[0] <= target:
                if nums[m] < nums[0]:
                    nums[m] = +inf
            # target on right, nums[m] on left
            else:
                if nums[m] >= nums[0]:
                    nums[m] = -inf

            if nums[m] == target:
                return m
            elif nums[m] <target:
                i = m + 1
            else:
                j = m - 1
        return -1
```

# [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

示例 1:
```
输入: num1 = "2", num2 = "3"
输出: "6"
```
示例 2:
```
输入: num1 = "123", num2 = "456"
输出: "56088"
```
说明：
```
num1 和 num2 的长度小于110。
num1 和 num2 只包含数字 0-9。
num1 和 num2 均不以零开头，除非是数字 0 本身。
不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。
```

代码：
```python3
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"
        
        m, n = len(num1), len(num2)
        res = [0] * (m + n)

        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                y = int(num2[j])
                res[i + j + 1] += x * y
            
        for i in range(m + n - 1, 0, -1):
            res[i - 1] += res[i] // 10
            res[i] = res[i] % 10
        index = 1 if res[0] == 0 else 0
        return reduce(lambda x, y: x + str(y), res[index:], "")
```

# [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：
```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
示例 2：
```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```
示例 3：
```
输入：nums = [1]
输出：[[1]]
```

提示：
```
1 <= nums.length <= 6
-10 <= nums[i] <= 10
nums 中的所有整数 互不相同
```

代码：
```python3
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(i: int) -> None:
            """i is th position to fixed"""
            if i == n:
                self.res.append(list(nums))
                return

            for j in range(i, n):
                nums[i], nums[j] = nums[j], nums[i]
                dfs(i + 1)
                nums[i], nums[j] = nums[j], nums[i]

        n = len(nums)
        self.res = []
        dfs(0)
        return self.res
```

# [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：

<img src=https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg width="700"/>

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```
示例 2：

<img src=https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg width="700"/>

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

提示：
```
m == matrix.length
n == matrix[i].length
1 <= m, n <= 10
-100 <= matrix[i][j] <= 100
```

代码：
```python3
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        dic = {"up": "right", "right": "down", "down": "left", "left": "up"}
        pos = "up"

        res = []
        while matrix and matrix[0]:
            if pos == "up":
               res += matrix.pop(0) 
            elif pos == "right":
                for row in matrix:
                    res.append(row.pop())
            elif pos == "down":
                res += matrix.pop()[::-1]
            elif pos == "left":
                for row in matrix[::-1]:
                    res.append(row.pop(0))
            pos = dic[pos]
        return res
```

# [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

 

示例 1：

<img src=https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg width="700">

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```
示例 2：
```
输入：n = 1
输出：[[1]]
```

提示：
```
1 <= n <= 20
```

代码：
```python3

```

# [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

 

示例 1：

<img src=https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg width="700">

```
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```
示例 2：

<img src=https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg width="700">

```
输入：head = [0,1,2], k = 4
输出：[2,0,1]
```

提示：
```
链表中节点的数目在范围 [0, 500] 内
-100 <= Node.val <= 100
0 <= k <= 2 * 109
```

代码：
```python3

```

# [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：

<img src=https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png width="700">

```
输入：m = 3, n = 7
输出：28
```
示例 2：
```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```
示例 3：
```
输入：m = 7, n = 3
输出：28
```
示例 4：
```
输入：m = 3, n = 3
输出：6
```

提示：
```
1 <= m, n <= 100
题目数据保证答案小于等于 2 * 109
```

代码：
```python3

```

# [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```
示例 2：
```
输入：nums = [0]
输出：[[],[0]]
```

提示：
```
1 <= nums.length <= 10
-10 <= nums[i] <= 10
nums 中的所有元素 互不相同
```

代码：
```python3

```

# [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。

格雷编码序列必须以 0 开头。

 

示例 1:
```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
```
示例 2:
```
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
```

代码：
```python3

```

# [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
```
说明：不允许修改给定的链表。
```
进阶：
```
你是否可以使用 O(1) 空间解决此题？
```

示例 1：

<img src=https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png width="700">

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```
示例 2：

<img src=https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png width="700">

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```
示例 3：

<img src=https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png width="100">

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

提示：
```
链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引
```

代码：
```python3

```

# [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：
```
1. LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
2. int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
3. void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
```
```
进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？
```
 

示例：
```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

提示：
```
1 <= capacity <= 3000
0 <= key <= 10000
0 <= value <= 105
最多调用 2 * 105 次 get 和 put
```

代码：
```python3

```

# [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

进阶：
```
你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
```

示例 1：

<img src=https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg width="700">

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```
示例 2：

<img src=https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg width="700">

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```
示例 3：
```
输入：head = []
输出：[]
```

提示：
```
链表中节点的数目在范围 [0, 5 * 104] 内
-105 <= Node.val <= 105
```

代码：
```python3

```

# [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 

示例 1:
```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```
示例 2:
```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

提示：
```
1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104
```

代码：
```python3

```

# [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。

 

示例 1：

<img src=https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg width="700">

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```
示例 2：

<img src=https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg width="700">

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```
 

提示：
```
树中的节点数为 n 。
1 <= k <= n <= 104
0 <= Node.val <= 104
```
```
进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？
```

代码：
```python3

```

# [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

 

示例 1：

<img src=https://assets.leetcode.com/uploads/2018/12/14/binarytree.png width="700">

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```
示例 2：

<img src=https://assets.leetcode.com/uploads/2018/12/14/binarytree.png width="700">

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```
示例 3：
```
输入：root = [1,2], p = 1, q = 2
输出：1
```

提示：
```
树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。
```

代码：
```python3

```

# [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

 

示例:
```
输入: [1,2,3,4]
输出: [24,12,8,6]
```
```
提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
```
```
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
```
```
进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
```

代码：
```python3

```